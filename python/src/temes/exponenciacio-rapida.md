# ExponenciaciÃ³ rÃ pida

<img src='./exponenciacio-rapida.png' style='height: 8em; float: right; margin: 0 0 1em 1em;'/>

Aquesta lliÃ§Ã³ presenta el mÃ¨tode de l'exponenciaciÃ³ rÃ pida. Amb aquest mÃ¨tode, potÃ¨ncies del tipus $x^n$ es poden calcular utilitzant uns $\log n$ productes, enlloc dels $n$ que caldrien amb un mÃ¨tode mÃ©s ingenu. Per explicar la tÃ¨cnica es presenta primer el cas de l'exponenciaciÃ³ de reals. DesprÃ©s aquesta idea s'aplica a l'exponenciaciÃ³ modular, a l'exponenciaciÃ³ de matrius quadrades, i al cÃ lcul de nombres de Fibonacci.


## ExponenciaciÃ³ bÃ sica

Si volem elevar un valor $x$ a un nombre natural $n$ per obtenir $x^n$, la soluciÃ³ mÃ©s natural Ã©s fer un bucle que multipliqui $x$ per ella mateixa $n$ cops:

```python
def exp(x: float, n: int) -> float:
    """Retorna x^n, amb n â‰¥ 0."""

    r = 1.0
    for _ in range(n):
        r *= x
    return r
```

Alguns direu que no calia aquest algorisme, que calcular l'expressiÃ³ `x ** n` era suficient... Per reals, teniu raÃ³. PerÃ² d'aquÃ­ un moment elevarem objectes que sÃ³n nÃºmeros. PaciÃ¨ncia.

En tot cas, Ã©s clar que el temps d'aquest algorisme Ã©s $O(n)$, Ã©s a dir, lineal amb el valor de l'exponent. Es podria fer millor?


## ExponenciaciÃ³ rÃ pida

Per poder calcular exponenciacions mÃ©s rÃ pidament, podem intentar formular una soluciÃ³ recursiva al problema. Comencem per aquÃ­:

- Quan $n=0$, tenim $x^n=x^0=1$. AixÃ² pot constituir el nostre cas base.

- Quan $n>0$, tenim $x^n=x Â· x^{n-1}$. AixÃ² pot constituir el nostre cas recursiu.

Amb aquest idea, ens surt la funciÃ³ recursiva segÃ¼ent:

```python
def exp(x: float, n: int) -> float:
    """Retorna x^n, amb n â‰¥ 0."""

    if n == 0:
        return 1.0
    else:
        return x * exp(x, n - 1)
```

PerÃ² aquest algorisme tambÃ© Ã©s lineal, ja que farÃ  $n$ productes igual que l'iteratiu. 

Ara bÃ©, podem afinar una mica millor la recurrÃ¨ncia tenint en compte la paritat de l'exponent en el cas recursiu:

- Quan $n=0$, tenim $x^n=x^0=1$, igual que abans. 

- Quan $n>0$ i $n$ Ã©s parell, tenim $x^n=x^{n/2}Â·x^{n/2}=\left(x^{n/2}\right)^2$.

- Quan $n>0$ i $n$ Ã©s senar, tenim $x^n=x^{n/2}Â·x^{n-n/2}=x^{n/2}Â·x^{n/2}Â·x=\left(x^{n/2}\right)^2Â·x$. AquÃ­, $n/2$ denota la divisiÃ³ entera de $n$ entre $2$.

La traducciÃ³ d'aquesta idea a Python Ã©s directa:

```python
def exp(x: float, n: int) -> float:
    """Retorna x^n, amb n â‰¥ 0."""

    if n == 0:
        return 1.0
    else:
        y = exp(x, n // 2)
        if n % 2 == 0:
            return y * y
        else:
            return y * y * x
```

Ara, com que a cada crida recursiva l'exponent es divideix per dos, l'algorisme resultant tÃ© cost $O(\log n)$, Ã©s a dir, logarÃ­tmic respecte l'exponent. Una millora espectacular! Aquest algorisme s'anomena l'**algorisme d'exponenciaciÃ³ rÃ pida**.

Fixeu-vos que a la funciÃ³ anterior Ã©s capital cridar recursivament nomÃ©s un cop i desar el resultat en una variable auxiliar (`y`). Si s'haguÃ©s cridat dos cops, el cost continuaria sent lineal ja que es repetirien un munt de cÃ lculs.

**Exercici:** Implementeu iterativament l'algorisme d'exponenciaciÃ³ rÃ pida.


## ExponenciaciÃ³ modular rÃ pida

En l'Ã rea de la criptografia, en moltes ocasions Ã©s necessari calcular el resultat de $x^n \pmod m$ per a $x, n, m$ naturals. Es podria resoldre aquest problema per forÃ§a bruta calculant $x^n$ primer i desprÃ©s fent-ne el mÃ²dul, perÃ² com que els nombres que apareixen en aplicacions criptogrÃ fiques solen ser molt grans, $x^n$ seria enorme. Cal tenir en compte que la velocitat dels cÃ lculs amb enters depenen de la seva grandÃ ria. Per tant, Ã©s convenient buscar un mÃ¨tode mÃ©s eficient. 

Per fer-ho, Ã©s clau adonar-se d'aquest fet: La multiplicaciÃ³ mantÃ© les congruÃ¨ncies. Ã‰s a dir, si $a = b \pmod n$, llavors  $aÂ·k = b \pmod n$.

AixÃ­, es pot usar la idea de l'exponenciaciÃ³ rÃ pida, fent que cada resultat temporal s'empetiteixi fent-ne el mÃ²dul immediatament (enlloc de deixar-lo pel final). Aquesta en podria ser la implementaciÃ³ resultant:


```python
def expmod(x: int, n: int, m: int) -> int:
    """Retorna (x^n) mod n. Prec: x, n â‰¥ 0 i m > 0."""

    if x == 0:
        return 1
    else:
        y = expmod(x, n // 2, m)
        if n % 2 == 0:
            return (y * y) % m
        else:
            return (((y * y) % m) * x) % m
```

Fixeu-vos que la darrera branca aplica el mÃ²dul desprÃ©s de cada producte. `(y * y * x) % n` tambÃ© seria correcte, perÃ² crearia valors temporals mÃ©s grans, reduint la velocitat d'execuciÃ³.

**Nota:** La funciÃ³ predefinida `pow` pot rebre un tercer parÃ metre, de forma que `pow(x, n, m)` justament calcula `(x ** n) % p`. Probablement usa un algorisme com el que hem descrit. 


## PotÃ¨ncies de matrius quadrades

Considerem ara el problema de calcular $A^n$, on $n$ Ã©s un natural i $A$ Ã©s una matriu quadrada.

En una [lliÃ§Ã³ anterior](/matrius/mates.html) ja vam desenvolupar una funciÃ³ per multiplicar matrius quadrades:

```python
from typing import TypeAlias

Matriu: TypeAlias = list[list[Fila]]


def producte(A: Matriu, B: Matriu) -> Matriu:
    """Retorna el producte de A i B, sabent que les dues sÃ³n quadrades."""

    n = len(A)
    return [
        [
            sum([A[i][k] * B[k][j] for k in range(n)]) 
            for j in range(n) 
        ] 
        for i in range(n)
    ]
```

Suposem que tenim creada la funciÃ³ producte que hem definit abans. Clarament, per elevar al quadrat una matriu no cal mÃ©s que fer el producte per ella mateixa, com

```python
M_quadrat = producte(M, M)
```

Si el que volem ara Ã©s calcular potÃ¨ncies mÃ©s grans de la matriu `A`, podem, de nou, utilitzar la tÃ¨cnica de l'exponenciaciÃ³ rÃ pida: 

- Quan $n$ Ã©s zero, cal retornar la matriu unitÃ ria, Ã©s a dir, la matriu on tot sÃ³n zeros menys la diagonal, que Ã©s plena de uns.

- Quan $n$ Ã©s parell, la potÃ¨ncia n-Ã¨sima es pot descompondre com el producte $A^n = A^{n/2} * A^{n/2}$.

- I quan `n` Ã©s senar, podem descompondre el producte com $A^n = A * \left(A^{n/2}\right)^2$. 

Un altre cop, la grÃ cia d'aquesta descomposiciÃ³ Ã©s que, com que les dues matrius que multipliquem sÃ³n iguals, no cal que la calculem dos cops, i aixÃ­ cada cop que ens trobem amb un $n$ parell ens estarem estalviant la meitat dels productes que ens queden. Tot aixÃ² funciona perquÃ¨ el producte de matrius quadrades Ã©s associatiu.

```python
def potencia(A: Matriu, n: int) -> Matriu:
    """Retorna A^n per una matriu quadrada A i un natural n."""

    if n == 0:
        m = len(A)
        # retorna matriu unitÃ ria
        return [[1 if i == j else 0 for j in range(m)] for i in range(m)]
    else:
        B = potencia(A, n // 2)
        if n % 2 == 0:
            return producte(B, B)
        else:
            return producte(A, producte(B, B))
```

AixÃ­, el nombre de productes de matrius que estem fent ara serÃ  de l'ordre de $\log(n)$. Com que el producte de dues matrius $n\times n$ Ã©s $O(n^3)$, l'algorisme resultant Ã©s $O(n^3\log n)$.


## Nombres de Fibonacci

Recordeu que la seqÃ¼Ã¨ncia de Fibonacci es defineix de la forma segÃ¼ent:

$$F(n) = \begin{cases} n & \text{si}\ n\le 1, \\\ F(n-1)+F(n-2) & \text{altrament.}\end{cases}$$

Els seus primers elements sÃ³n 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377.

Considerem la matriu
$$
M =
\left(\begin{array}{cc}
0 & 1 \\\
1 & 1
\end{array}\right) =
\left(\begin{array}{cc}
F_0 & F_1 \\\
F_1 & F_2
\end{array}\right).
$$

Definirem tambÃ© les matrius $M_n$ com
$$
M_n =
\left(\begin{array}{cc}
F\_n & F\_{n+1} \\\
F\_{n+1} & F\_{n+2}
\end{array}\right).
$$
Es pot veure clarament que $M = M_0$. 

Vegem quÃ¨ passa quam fem el producte de la matriu $M$ per la matriu $M_n$:

!!! Merda, falta arreglar totes aquestes mates.

$$
\left(\begin{array}{cc}
0 & 1 \\\
1 & 1
\end{array}\right)
\left(\begin{array}{cc}
F\_{n} & F\_{n+1} \\\
F\_{n+1} & F\_{n+2}
\end{array}\right) =
\left(\begin{array}{cc}
F\_{n+1} & F\_{n+2} \\\
F\_{n}+F\_{n+1} & F\_{n+1}+F\_{n+2}
\end{array}\right) =
\left(\begin{array}{cc}
F\_{n+1} & F\_{n+2} \\\
F\_{n+2} & F\_{n+3}
\end{array}\right)
$$

Ã‰s a dir, $M\cdot M_n = M_{n+1}$ per qualsevol $n$! En particular tenim que
$M^2 = M\cdot M_0 = M_1$, $M^3 = M\cdot M_1 = M_2$, i aixÃ­ successivament.
Per tant, $M^n = M_{n-1}$ per qualsevol $n$. I ara ve la millor part:
nosaltres sabem calcular la potÃ¨ncia
d'una matriu quadrada fent nomÃ©s uns $\log(n)$ productes ðŸ˜ƒ. AixÃ­, per trobar
el terme $F_n$ de la successiÃ³ de Fibonacci, nomÃ©s hem de calcular la potÃ¨ncia
$n+1$-Ã¨sima de $M$ (que Ã©s $M_n) i mirar el primer element, i ho podem fer en un nombre d'operacions
logarÃ­tmic. 

Amb tots els deures fets, la implementaciÃ³ Ã©s doncs ben senzilla:

```python
def fibonacci(n: int) -> int:
    """Retorna l'n-Ã¨sim nombre de Fibonacci."""

    M = [[0, 1], 
         [1, 1]]
    Mn = potencia(M, n) 
    return Mn[1][0]
```

Tenint en compte que les matrius que ens aparÃ¨ixen en aquesta aplicaciÃ³ sÃ³n totes de mida $2\times2$, potser val la pena optimitzar el seu producte substituint els bucles pels valors finals:

```python
def producte2x2(A, B):
    """Retorna A*B on A i B sÃ³n matrius 2Ã—2"""

    [[a, b],
     [c, d]] = A        
    [[p, q],            
     [r, s]] = B
    return [[a*p + b*r, a*q + b*s],
            [c*p + d*r, c*q + d*s]]
```

Fixeu-vos com es poden desempaquetar els valors individuals continguts a les matrius.


**ObservaciÃ³:** Potser trobareu alguna font que us explicarÃ  que els nombres de Fibonacci es poden calcular amb la fÃ³rmula tancada segÃ¼ent:

$$
F_n = \dfrac{\varphi^n}{\sqrt5}+\frac12
$$
on $\varphi$ Ã©s el nombre auri
$$
\varphi = \dfrac{1 + \sqrt5}{2}.
$$

AixÃ² dÃ³na lloc a la segÃ¼ent implementaciÃ³ que funciona en temps constant:

```python
def fibonacci(n: int) -> int:
    """Retorna l'n-Ã¨sim nombre de Fibonacci"""
       
    Ï• = (1 + math.sqrt(5)) / 2
    return int(Ï•**n / math.sqrt(5) + 1/2)
```

Malauradament, degut als problemes de precisiÃ³ dels nombres de coma flotant, aquesta funciÃ³ falla a partir de $n=71$.


<Autors autors="jpetit"/> 

